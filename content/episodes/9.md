---
title: Domain Modeling Made Functional, Part 2 with Scott Wlaschin
date: 2025-09-19T07:00:00.000Z
subtitle: Exploring functional programming concepts, how they complement DDD, and practical techniques for modeling domains functionally.
description: In this episode, Scott Wlaschin shows how functional programming concepts can enhance domain-driven design, sharing practical techniques for building more expressive, testable domain models using functional approaches.
file: 009-domain-modeling-made-functional-part-2-with-scott-wlaschin.mp3
size: 66449076
duration: 4143
hash: 0e52370599ca5b89406bf0fc95669ff3
---

We continue our conversation with Scott Wlaschin, author of "Domain Modeling Made Functional" and creator of the popular F# for Fun and Profit blog, as we dive into functional programming concepts and how they naturally complement domain-driven design.

In this episode, we explore the practical aspects of functional programming - from understanding what makes a language functional to implementing robust error handling patterns and modeling domain concepts functionally.

Topics include:

- What functional programming really means
- The difference between the FP paradigm and FP languages
- Why functional languages make certain patterns natural (immutability, currying, partial application)
- Railway-oriented programming and functional error handling patterns
- How functional programming approaches dependency injection differently
- Three types of errors: panics, domain exceptions, and infrastructure errors
- How functional programming helps with domain modeling through composable data types
- Pipeline-oriented programming and workflow modeling
- Modeling DDD concepts functionally: entities, value objects, and aggregates
- Why functional programming language usage is still less common than OO languages
- AI's impact on programming and the importance of domain expertise
- Learning strategies and the value of multi-paradigm programming

Scott also shares insights on why he prefers using languages "with the grain" rather than forcing paradigms where they don't fit naturally.
He demonstrates practical examples of how functional programming makes domain modeling more explicit and testable, while discussing the trade-offs between different programming paradigms and when each is most appropriate.

We conclude with Scott's thoughts on AI in software development - why it's a tool for augmentation rather than replacement, the importance of understanding fundamentals, and how the subscription model might impact the industry.

_This is Part 2 of a 2-part series. In [Part 1](https://compiledconversations.com/8/), we explored the fundamentals of domain-driven design - including strategic vs. tactical DDD, (sub)domains, bounded contexts, ubiquitous language, and the critical importance of communication in software design._

**Show Links**

- [Scott Wlaschin's Website](https://scottwlaschin.com/)
- [Scott Wlaschin on X/Twitter](https://x.com/ScottWlaschin)
- [Scott Wlaschin on Bluesky](https://bsky.app/profile/scottwlaschin.bsky.social)
- [Scott Wlaschin on GitHub](https://github.com/swlaschin)
- [F# for Fun and Profit](https://fsharpforfunandprofit.com/)
- [Domain Modeling Made Functional](https://pragprog.com/titles/swdddf/domain-modeling-made-functional/)
- [Railway-Oriented Programming](https://fsharpforfunandprofit.com/rop/)
- [Starbucks Does Not Use Two-Phase Commit](https://www.enterpriseintegrationpatterns.com/ramblings/18_starbucks.html)
- [Understanding F# types](https://fsharpforfunandprofit.com/posts/types-intro/)
- [Thinking Functionally](https://fsharpforfunandprofit.com/posts/thinking-functionally-intro/)
- [Commit Strip - A very comprehensive and precise spec](https://www.commitstrip.com/en/2016/08/25/a-very-comprehensive-and-precise-spec/)
- [Moving IO to the edges of your app: Functional Core, Imperative Shell](https://www.youtube.com/watch?v=P1vES9AgfC4)
